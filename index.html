<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hollow Knight Timer</title>
<style>
/* --- existing styles unchanged --- */
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{
  background:url('image.png') center/cover no-repeat fixed;
  min-height:100vh;font-family:'Cinzel',serif;color:#f5f5dc;overflow-x:hidden;position:relative;
}
#particleCanvas{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1}
.container{max-width:1000px;margin:0 auto;padding:40px 20px;text-align:center}
.title{font-size:3rem;letter-spacing:.15em;margin-bottom:5px}
.title-underline{display:block;width:200px;margin:4px auto 20px auto;height:auto}
/* slots */
.activity-slots{margin-top:20px;position:relative}
.slot-wrap{display:flex;justify-content:center;align-items:center;gap:20px;margin:28px 0;position:relative}
.activity-slot{
  display:flex;align-items:center;gap:20px;padding:20px 30px;
  background:linear-gradient(to right,rgba(0,0,0,0)0%,rgba(0,0,0,0.55)15%,rgba(0,0,0,0.55)85%,rgba(0,0,0,0)100%);
  border-top:2px solid rgba(245,245,220,0.4);transition:background .2s ease;
  min-width:500px;position:relative;z-index:0;border-radius:10px;
}
.slot-wrap.selected .activity-slot{
  background:linear-gradient(to right,rgba(255,255,255,0.0)0%,rgba(255,255,255,0.15)15%,rgba(255,255,255,0.15)85%,rgba(255,255,255,0.0)100%);
  border-top-color:#f5f5dc;
}
.corner-circle{position:absolute;top:0;left:0;width:50px;height:50px;z-index:1}
.side-icon-left,.side-icon-right{width:50px;height:50px;display:none;position:absolute;top:50%;transform:translateY(-50%)}
.slot-wrap.selected .side-icon-left{left:-60px;display:block}
.slot-wrap.selected .side-icon-right{right:-60px;display:block}
.slot-left{display:flex;align-items:center;gap:20px;font-family:'Cinzel',serif}
.slot-number{font-size:2rem;opacity:.85}
.activity-input{
  background:transparent;
  border:none;
  font-size:1.6rem;
  color:#f5f5dc;
  outline:none;
  font-family:'Cinzel',serif;
  padding:4px 8px;
  border-radius:4px;
  transition:background .15s ease;
}
.activity-input.selected{
  background:rgba(245,245,220,0.1);
}
.timer-controls{display:flex;gap:10px;align-items:center}
.mini-timer{font-size:1.4rem;min-width:140px;text-align:center;white-space:nowrap}
.mini-btn{
  background:rgba(245,245,220,0.1);
  border:1px solid rgba(245,245,220,0.3);
  border-radius:4px;
  color:#f5f5dc;
  font-size:1.3rem;
  cursor:pointer;
  transition:all .15s ease;
  padding:8px 12px;
  box-shadow:0 2px 4px rgba(0,0,0,0.2);
}
.mini-btn:hover,
.mini-btn.selected{
  transform:scale(1.1);
  background:rgba(245,245,220,0.2);
  border-color:rgba(245,245,220,0.5);
  box-shadow:0 4px 8px rgba(0,0,0,0.3);
}
.mini-btn.selected{
  background:rgba(245,245,220,0.25);
  border-color:rgba(245,245,220,0.6);
  box-shadow:0 0 8px rgba(245,245,220,0.3);
}
.mini-btn:active{
  transform:scale(0.95);
  box-shadow:0 1px 2px rgba(0,0,0,0.3);
}
.clear-save{
  font-size:1.6rem;
  font-family:'Cinzel',serif;
  color:#fff;
  text-transform:uppercase;
  background:rgba(245,245,220,0.05);
  border:1px solid transparent;
  border-radius:4px;
  cursor:pointer;
  visibility:hidden;
  padding:8px 16px;
  transition:all .15s ease;
}
.clear-save:hover,
.clear-save.selected{
  background:rgba(245,245,220,0.15);
  transform:scale(1.02);
}
.clear-save.selected{
  background:rgba(245,245,220,0.1);
  border-color:rgba(245,245,220,0.2);
}
.clear-save:active{
  transform:scale(0.98);
  background:rgba(245,245,220,0.1);
}
.slot-wrap.selected .clear-save{visibility:visible}
.controls{margin-top:40px}
.add-slot-btn{
  background:rgba(245,245,220,0.1);
  border:1px solid rgba(245,245,220,0.3);
  border-radius:4px;
  font-family:'Cinzel',serif;
  font-size:1.6rem;
  color:#fff;
  text-transform:uppercase;
  cursor:pointer;
  padding:12px 24px;
  box-shadow:0 2px 4px rgba(0,0,0,0.2);
  transition:all .15s ease;
}
.add-slot-btn:hover,
.add-slot-btn.selected{
  transform:scale(1.05);
  background:rgba(245,245,220,0.2);
  border-color:rgba(245,245,220,0.5);
  box-shadow:0 4px 8px rgba(0,0,0,0.3);
}
.add-slot-btn.selected{
  background:rgba(245,245,220,0.25);
  border-color:rgba(245,245,220,0.6);
  box-shadow:0 0 8px rgba(245,245,220,0.3);
}
.add-slot-btn:active{
  transform:scale(0.98);
  box-shadow:0 1px 2px rgba(0,0,0,0.3);
}
</style>
</head>

<body>
<canvas id="particleCanvas"></canvas>

<div class="container">
  <h1 class="title">HOLLOW KNIGHT TIMER</h1>
  <img src="title.png" class="title-underline" alt="Title SVG">
  <div class="activity-slots" id="activitySlots"></div>
  <div class="controls"><button class="add-slot-btn" id="addSlotBtn">ADD SLOT</button></div>
</div>

<script>
/* ---------- timers & storage ---------- */
let timers = {};        // {slotId: {seconds,name,running}}
let intervals = {};
let slotCounter = 0;
let currentIndex = 0, slotWraps = [], lastMouseMoveTime = 0;
let selectedControl = 0; // 0=input, 1=start, 2=pause, 3=reset, 4=clear save
let addSlotSelected = false; // Track if Add Slot button is selected
const STORAGE_KEY = 'hkTimers';

/* helpers */
function formatTime(s){
  const h=Math.floor(s/3600),m=Math.floor((s%3600)/60),sec=s%60;
  return `${String(h).padStart(2,'0')}H ${String(m).padStart(2,'0')}M ${String(sec).padStart(2,'0')}S`;
}
function persist(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(timers)); }

function getSlotData(slot){
  return {
    slotId:slot.dataset.slot,
    input:slot.querySelector('.activity-input'),
    timerDisplay:slot.querySelector('.mini-timer'),
    startBtn:slot.querySelector('.start-btn'),
    pauseBtn:slot.querySelector('.pause-btn'),
    resetBtn:slot.querySelector('.reset-btn')
  };
}

/* core timer ops */
function startTimer(slot){
  const {slotId,timerDisplay}=getSlotData(slot);
  if (!timers[slotId]) timers[slotId]={seconds:0,name:'',running:false};
  if (intervals[slotId]) clearInterval(intervals[slotId]);
  timers[slotId].running=true;
  intervals[slotId]=setInterval(()=>{
    timers[slotId].seconds++;
    timerDisplay.textContent=formatTime(timers[slotId].seconds);
    persist();
  },1000);
}
function pauseTimer(slot){
  const {slotId}=getSlotData(slot);
  if (intervals[slotId]){clearInterval(intervals[slotId]);delete intervals[slotId];}
  if (timers[slotId]) timers[slotId].running=false;
  persist();
}
function resetTimer(slot){
  const {slotId,timerDisplay}=getSlotData(slot);
  if (intervals[slotId]){clearInterval(intervals[slotId]);delete intervals[slotId];}
  if (!timers[slotId]) timers[slotId]={};
  timers[slotId].seconds=0; timers[slotId].running=false;
  timerDisplay.textContent=formatTime(0); persist();
}
function clearSlot(slot){
  const {slotId,input,timerDisplay}=getSlotData(slot);
  pauseTimer(slot);
  // Reset the timer data instead of deleting it
  timers[slotId] = {seconds: 0, name: '', running: false};
  timerDisplay.textContent=formatTime(0);
  input.value='';
  persist();
}

/* slot creation */
function createSlot(id,data={}){
  const cont=document.getElementById('activitySlots');
  const wrap=document.createElement('div');
  wrap.className='slot-wrap';
  const slotId = id || (++slotCounter);
  wrap.innerHTML=`
    <img src="corner.png" class="corner-circle" alt="Corner SVG">
    <img src="left.png" class="side-icon-left" alt="Left selection SVG">
    <div class="activity-slot" data-slot="${slotId}">
      <div class="slot-left">
        <span class="slot-number">${slotId}.</span>
        <input type="text" class="activity-input" placeholder="Activity Name" value="${data.name||''}">
        <div class="timer-controls">
          <div class="mini-timer">${formatTime(data.seconds||0)}</div>
          <button class="mini-btn start-btn">▶</button>
          <button class="mini-btn pause-btn">⏸</button>
          <button class="mini-btn reset-btn">⏹</button>
        </div>
      </div>
    </div>
    <img src="right.png" class="side-icon-right" alt="Right selection SVG">
    <button class="clear-save">CLEAR SAVE</button>`;
  cont.appendChild(wrap);

  timers[slotId] = {seconds:data.seconds||0, name:data.name||'', running:false};
  setupSlotEvents(wrap.querySelector('.activity-slot'), wrap);
  refreshSlots();

  /* resume running timer if needed */
  if (data.running){ startTimer(wrap.querySelector('.activity-slot')); }
}

function setupSlotEvents(slot,wrap){
  const {startBtn,pauseBtn,resetBtn,input,slotId}=getSlotData(slot);
  startBtn.onclick=e=>{e.preventDefault();startTimer(slot);};
  pauseBtn.onclick=e=>{e.preventDefault();pauseTimer(slot);};
  resetBtn.onclick=e=>{e.preventDefault();resetTimer(slot);};
  input.oninput=()=>{ if(timers[slotId]){timers[slotId].name=input.value;persist();}};
  wrap.querySelector('.clear-save').onclick=e=>{e.preventDefault();clearSlot(slot);};
  wrap.onmousemove=()=>{lastMouseMoveTime=Date.now();currentIndex=slotWraps.indexOf(wrap);selectedControl=0;addSlotSelected=false;highlightRow(currentIndex);}
}

function highlightRow(i){
  // Handle Add Slot button selection
  const addSlotBtn = document.getElementById('addSlotBtn');
  addSlotBtn.classList.toggle('selected', addSlotSelected);
  
  slotWraps.forEach((wrap,idx)=>{
    const isSelected = idx === i && !addSlotSelected;
    wrap.classList.toggle('selected', isSelected);
    if (isSelected) {
      // Highlight the selected control
      const input = wrap.querySelector('.activity-input');
      const startBtn = wrap.querySelector('.start-btn');
      const pauseBtn = wrap.querySelector('.pause-btn');
      const resetBtn = wrap.querySelector('.reset-btn');
      const clearBtn = wrap.querySelector('.clear-save');
      
      input.classList.toggle('selected', selectedControl === 0);
      startBtn.classList.toggle('selected', selectedControl === 1);
      pauseBtn.classList.toggle('selected', selectedControl === 2);
      resetBtn.classList.toggle('selected', selectedControl === 3);
      clearBtn.classList.toggle('selected', selectedControl === 4);
      
      // Focus the input when it's selected
      if (selectedControl === 0) {
        input.focus();
      } else {
        input.blur();
      }
    } else {
      // Remove highlights from non-selected rows
      const input = wrap.querySelector('.activity-input');
      input.classList.remove('selected');
      input.blur();
      wrap.querySelector('.start-btn').classList.remove('selected');
      wrap.querySelector('.pause-btn').classList.remove('selected');
      wrap.querySelector('.reset-btn').classList.remove('selected');
      wrap.querySelector('.clear-save').classList.remove('selected');
    }
  });
}
function refreshSlots(){slotWraps=[...document.querySelectorAll('.slot-wrap')];highlightRow(currentIndex);}

/* init */
function initialize(){
  // restore from storage if present
  const saved=localStorage.getItem(STORAGE_KEY);
  if(saved){
    const parsed=JSON.parse(saved);
    const maxId = Math.max(0, ...Object.keys(parsed).map(Number));
    // Always create at least 4 slots, numbered 1-4
    for(let i = 1; i <= Math.max(4, maxId); i++){
      const data = parsed[i] || {seconds: 0, name: '', running: false};
      createSlot(i, data);
    }
    slotCounter = Math.max(4, maxId);
  } else {
    for(let i=1; i<=4; i++) createSlot(i, {seconds: 0, name: '', running: false});
    slotCounter = 4;
  }

  document.getElementById('addSlotBtn').onclick=()=>{
    createSlot();
    refreshSlots();
    // Scroll the new slot into view
    setTimeout(() => {
      const newSlot = slotWraps[slotWraps.length - 1];
      if (newSlot) {
        newSlot.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, 100);
  };

  document.addEventListener('keydown',e=>{
    const now=Date.now();
    if(now-lastMouseMoveTime>200){
      if(e.key==='ArrowDown'){
        e.preventDefault();
        if(addSlotSelected){
          // Do nothing, already at bottom
        } else if(currentIndex === slotWraps.length - 1){
          // Move from last row to Add Slot button
          addSlotSelected = true;
          selectedControl = 0;
        } else {
          // Move to next row
          currentIndex = (currentIndex + 1) % slotWraps.length;
          selectedControl = 0;
          addSlotSelected = false;
        }
        highlightRow(currentIndex);
      }
      else if(e.key==='ArrowUp'){
        e.preventDefault();
        if(addSlotSelected){
          // Move from Add Slot to last row
          addSlotSelected = false;
          currentIndex = slotWraps.length - 1;
          selectedControl = 0;
        } else {
          // Move to previous row
          currentIndex = (currentIndex - 1 + slotWraps.length) % slotWraps.length;
          selectedControl = 0;
          addSlotSelected = false;
        }
        highlightRow(currentIndex);
      }
      else if(e.key==='ArrowRight' && !addSlotSelected){
        e.preventDefault();
        selectedControl = Math.min(4, selectedControl + 1);
        highlightRow(currentIndex);
      }
      else if(e.key==='ArrowLeft' && !addSlotSelected){
        e.preventDefault();
        selectedControl = Math.max(0, selectedControl - 1);
        highlightRow(currentIndex);
      }
      else if(e.key==='Enter'){
        e.preventDefault();
        if(addSlotSelected){
          const btn = document.getElementById('addSlotBtn');
          btn.style.transform = 'scale(0.98)';
          setTimeout(() => btn.style.transform = '', 150);
          createSlot();
          refreshSlots();
          // Scroll the new slot into view
          setTimeout(() => {
            const newSlot = slotWraps[slotWraps.length - 1];
            if (newSlot) {
              newSlot.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 100);
        } else {
          const currentSlot = slotWraps[currentIndex].querySelector('.activity-slot');
          if(selectedControl === 1) {
            const btn = slotWraps[currentIndex].querySelector('.start-btn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 150);
            startTimer(currentSlot);
          }
          else if(selectedControl === 2) {
            const btn = slotWraps[currentIndex].querySelector('.pause-btn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 150);
            pauseTimer(currentSlot);
          }
          else if(selectedControl === 3) {
            const btn = slotWraps[currentIndex].querySelector('.reset-btn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 150);
            resetTimer(currentSlot);
          }
          else if(selectedControl === 4) {
            const btn = slotWraps[currentIndex].querySelector('.clear-save');
            btn.style.transform = 'scale(0.98)';
            setTimeout(() => btn.style.transform = '', 150);
            clearSlot(currentSlot);
          }
        }
      }
      else if(e.key.length===1&&!e.ctrlKey&&!e.metaKey&&!e.altKey&&selectedControl===0&&!addSlotSelected){
        const input=slotWraps[currentIndex].querySelector('.activity-input');input.focus();
      }
    }
  });
}
document.readyState==='loading'?document.addEventListener('DOMContentLoaded',initialize):initialize();

/* ---------- particle effect ---------- */
const canvas=document.getElementById('particleCanvas');
const ctx=canvas.getContext('2d');
let w,h,particles=[];
function resizeCanvas(){w=canvas.width=window.innerWidth;h=canvas.height=window.innerHeight;}
window.addEventListener('resize',resizeCanvas);resizeCanvas();
class Particle{
  constructor(){this.reset();}
  reset(){this.x=Math.random()*w;this.y=Math.random()*h;this.size=Math.random()*2+1;
    this.speedX=Math.random()*0.5-0.25;this.speedY=Math.random()*0.5-0.25;this.opacity=Math.random()*0.6+0.2;}
  update(){this.x+=this.speedX;this.y+=this.speedY;
    if(this.x<0||this.x>w||this.y<0||this.y>h)this.reset();}
  draw(){ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fillStyle=`rgba(245,245,220,${this.opacity})`;ctx.fill();}
}
for(let i=0;i<100;i++)particles.push(new Particle());
(function animate(){
  ctx.clearRect(0,0,w,h);
  particles.forEach(p=>{p.update();p.draw();});
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>